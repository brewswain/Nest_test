import {
  Column,
  Entity,
  JoinColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
} from 'typeorm';

import { Event } from './event.entity';

// Am event needs attendees, so let's make this entity. We just want an id and a name for now.
// Now that we've made a simple Entity, check out event.entity.ts where we explore relations:
@Entity()
export class Attendee {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  // Ignore below until you check out the writeup on event.entity.ts

  // Assuming you came here from our Event entity, you'll know that we need an event field
  // of type Event. In this case, we'll use the @ManyToOne() decorator, which as you can
  // see, requires the same arguments as @OneToMany(). A function that returns the type of
  // our relation, and a function that returns the property of our related entity (in this
  // case, our attendees field).

  // As you've noticed however, we have a 3rd argument here! This third argument is optional,
  // providing some configurations that we may or may not want. Let's check it out:
  @ManyToOne(
    () => Event,
    (event) => event.attendees,
    // If we were to check our database, we can see how this relation is represented inside
    // of our new entity tables. In our attendee's case, we would see an eventId column. This
    // column should contain one of the IDs from the event table, or null. This entity being
    // able to contain a null field means that it can exist on its own--without a parent entity,
    // which in this case is Event. That's default behaviour that we don't want in this case,
    // which is where our optional config object here comes in. As we can see, it sets an option
    // called 'nullable' to false. Self-explanatory here, we're just not letting our eventId's
    // value be null, thus ensuring that in order for our child entity to exist, it must be
    // connected to a parent entity.
    {
      nullable: false,
    },
  )

  // By default our Column (eventId)'s name is autogenerated, and it points to the primary key
  // of the other entity. However, we can configure this by using the @JoinColumn() decorator on
  // our entity that has @ManyToOne(). Let's change eventId's name to new_event_name. Very creative,
  // I know. If we refresh our db we should see that change get reflected.
  @JoinColumn({
    name: 'beep',

    // If for some reason we wanted our eventId should point to a different column than the primary
    // key (id in this case), we can specify that column by using referencedColumnName:
    referencedColumnName: 'secondary',
  })
  event: Event;
}
